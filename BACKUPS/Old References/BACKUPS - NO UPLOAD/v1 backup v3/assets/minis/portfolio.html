<!-- portfolio mini • self-contained and scoped -->
<style>
  /* ---------- Base & tokens ---------- */
  .port{
    --font-ui: var(--font-ui, "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace);
    --fg: var(--fg, #e6e6e6);
    --bg: var(--bg, #0a0a0a);
    --cyan: #00ffc8;
    --panel-border: rgba(255,255,255,.25);
    --panel-shadow: rgba(0,0,0,.55);
    font-family: var(--font-ui);
    color: var(--fg);
  }
  .port h2{ margin:.25rem 0 .4rem; font-size:1rem; }

  /* ---------- Tracks row (centered, single line when possible) ---------- */
  .port .tracks{
    display:flex; justify-content:center; align-items:center;
    gap:.5rem; padding:.35rem 0 .5rem; flex-wrap:wrap;
  }
  .port .trk{
    flex:0 0 auto; cursor:pointer;
    font:700 .95rem/1 var(--font-ui); letter-spacing:.02em;
    color:var(--fg); background:rgba(0,0,0,.6);
    border:1px dashed var(--cyan); border-radius:9px;
    padding:.5rem .7rem; user-select:none;
    transition:transform .08s ease;
  }
  .port .trk:active{ transform:scale(.98) }
  .port .trk.active{ background:var(--cyan); color:#000; }
  .port .trk:focus-visible{ outline:2px solid var(--cyan); outline-offset:2px; }

  /* ---------- Player (custom, black) ---------- */
  .port .player{
    background:#000; border:1px solid var(--panel-border);
    border-radius:14px; padding:.6rem .75rem; margin-bottom:1rem;
    box-shadow:0 6px 40px var(--panel-shadow);
    position: relative;
  }
  .port .controls{
    display:flex; align-items:center; gap:.75rem;
  }
  .port .btn{
    width:48px; height:48px; border:0; background:transparent;
    display:inline-flex; align-items:center; justify-content:center;
    cursor:pointer; border-radius:10px;
  }
  .port .btn:focus-visible{ outline:2px solid var(--cyan); outline-offset:2px; }
  .port .btn svg{ width:28px; height:28px; fill:#fff; display:block; }

  /* Loading indicator */
  .port .loading-bar {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--cyan), transparent);
    background-size: 200% 100%;
    animation: loading-sweep 1.2s infinite linear;
    opacity: 0;
    transition: opacity 0.2s;
    border-radius: 14px 14px 0 0;
  }
  @keyframes loading-sweep {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
  .port .player.is-loading .loading-bar {
    opacity: 1;
  }

  /* Seek bar */
  .port .seek{ flex:1; display:flex; align-items:center; gap:.6rem; }
  .port .time{ font:600 .8rem/1 var(--font-ui); opacity:.9; min-width:4.2ch; text-align:right; }
  .port input[type="range"]{ -webkit-appearance:none; appearance:none; width:100%; height:6px; background:#222; border-radius:3px; }
  .port input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:#fff; }
  .port input[type="range"]::-moz-range-thumb{ width:14px; height:14px; border-radius:50%; background:#fff; border:0; }
  .port input[type="range"]:focus-visible { outline: 2px solid var(--cyan); outline-offset: 4px; }

  /* ---------- Gallery ---------- */
  .port .stage{
    position:relative; width:87%; margin:.6rem auto 1rem;
    aspect-ratio:16/9;
    background:#000; border:1px solid var(--panel-border);
    border-radius:12px; overflow:hidden; box-shadow:0 6px 40px var(--panel-shadow);
    touch-action:pan-y; /* allow vertical scrolling, keep horizontal for swipe */
  }
  @media (max-width: 740px){
    .port .stage{ aspect-ratio:4/5; }
  }
  .port .stage img{ 
    width:100%; height:100%; object-fit:contain; display:block; background:#000;
    transition: opacity 0.3s ease;
  }
  .port .stage img.loading { 
    opacity: 0.4;
  }
  .port .stage.error::after {
    content: "Image failed to load";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.7);
    font-size: 0.9rem;
  }

  .port .nav{
    position:absolute; top:50%; transform:translateY(-50%);
    width:46px; height:46px; border-radius:12px;
    background:rgba(0,0,0,.55); color:#fff;
    border:1px solid var(--panel-border); cursor:pointer; user-select:none;
    display:flex; align-items:center; justify-content:center;
    z-index:2;               /* ensure on top of image */
    pointer-events:auto;     /* ensure clickable even if parent has captures */
  }
  .port .nav.prev{ left:10px } .port .nav.next{ right:10px }
  .port .nav:focus-visible{ outline:2px solid var(--cyan); outline-offset:2px; }

  /* ---------- Resume button ---------- */
  .port .resume{ text-align:center; margin:.2rem 0 .2rem; }
  .port .resume a{
    display:inline-block; text-decoration:none; color:var(--fg);
    background:rgba(0,0,0,.6); border:1px dashed var(--cyan);
    border-radius:10px; padding:.5rem .9rem; letter-spacing:.02em;
  }
  .port .resume a:focus-visible{ outline:2px solid var(--cyan); outline-offset:2px; }

  /* Status message for screen readers */
  .port .sr-status {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }
</style>

<div class="port" id="port-root">
  <!-- tracks -->
  <div class="tracks" id="tracks"></div>

  <!-- player -->
  <div class="player" id="playerBox" role="group" aria-label="Music player">
    <div class="loading-bar"></div>
    <audio id="audio" preload="none" hidden></audio>
    <div class="controls">
      <button class="btn" id="playBtn" aria-label="Play" title="Play">
        <!-- play icon (switches to pause at runtime) -->
        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      </button>

      <div class="seek">
        <span class="time" id="cur">0:00</span>
        <input id="seek" type="range" min="0" max="100" value="0" step="0.1" aria-label="Seek">
        <span class="time" id="dur">0:00</span>
      </div>

      <button class="btn" id="muteBtn" aria-label="Mute" title="Mute">
        <!-- flat white speaker -->
        <svg viewBox="0 0 24 24"><path d="M4 9v6h4l5 4V5L8 9H4z"/></svg>
      </button>
    </div>
    <div id="playerStatus" class="sr-status" aria-live="polite"></div>
  </div>

  <!-- gallery -->
  <div class="stage" id="stage">
    <button class="nav prev" id="prev" aria-label="Previous image">‹</button>
    <img id="shot" alt="Portfolio artwork" class="loading">
    <button class="nav next" id="next" aria-label="Next image">›</button>
    <div id="galleryStatus" class="sr-status" aria-live="polite"></div>
  </div>

  <!-- resume -->
  <div class="resume">
    <a href="/assets/resume/resume.pdf" download>resume.pdf</a>
  </div>
</div>

<script>
(() => {
  /* ================== TRACK BUTTONS + PLAYER ================== */
  const AUDIO_BASE = '/assets/audio/';
  const tracks = [
    {file:'frark1',    label:'frark'},
    {file:'frark1999', label:'frark'},
    {file:'fulcrum',   label:'fulcrum'},
    {file:'gravity',   label:'gravity'},
    {file:'sttd',      label:'sttd'},
    {file:'trance',    label:'trance'},
    {file:'whatwhat',  label:'whatwhat'},
  ];
  const tracksBar = document.getElementById('tracks');
  const audio = document.getElementById('audio');
  const playerBox = document.getElementById('playerBox');
  const playBtn = document.getElementById('playBtn');
  const muteBtn = document.getElementById('muteBtn');
  const seek = document.getElementById('seek');
  const curT = document.getElementById('cur');
  const durT = document.getElementById('dur');
  const playerStatus = document.getElementById('playerStatus');

  let activeBtn = null;
  function pretty(t){
    if (!isFinite(t)) return '0:00';
    const m = Math.floor(t/60), s = Math.floor(t%60);
    return m + ':' + (s<10?'0':'') + s;
  }
  function setIcon(btn, type){
    // type: 'play' | 'pause' | 'speaker' | 'mute'
    const icons = {
      play:   '<path d="M8 5v14l11-7z"/>',
      pause:  '<path d="M6 5h4v14H6zm8 0h4v14h-4z"/>',
      speaker:'<path d="M4 9v6h4l5 4V5L8 9H4z"/>',
      mute:   '<path d="M4 9v6h4l5 4V5L8 9H4z M16 9l5 5m0-5l-5 5" stroke="#fff" stroke-width="2" fill="none"/>'
    };
    btn.querySelector('svg').innerHTML = icons[type];
    
    // Update ARIA attributes
    if (type === 'play') {
      btn.setAttribute('aria-label', 'Play');
      btn.setAttribute('title', 'Play');
    } else if (type === 'pause') {
      btn.setAttribute('aria-label', 'Pause');
      btn.setAttribute('title', 'Pause');
    } else if (type === 'speaker') {
      btn.setAttribute('aria-label', 'Mute');
      btn.setAttribute('title', 'Mute');
    } else if (type === 'mute') {
      btn.setAttribute('aria-label', 'Unmute');
      btn.setAttribute('title', 'Unmute');
    }
  }

  // Status message for screen reader users
  function announcePlayer(message) {
    playerStatus.textContent = message;
  }

  // build track buttons (centered line; wrap on very small widths)
  tracks.forEach(t => {
    const b = document.createElement('button');
    b.className = 'trk';
    b.textContent = t.label;
    b.dataset.src = AUDIO_BASE + t.file + '.mp3';
    b.addEventListener('click', () => {
      if (activeBtn) activeBtn.classList.remove('active');
      activeBtn = b; activeBtn.classList.add('active');
      audio.src = b.dataset.src;
      
      playerBox.classList.add('is-loading');
      announcePlayer(`Loading track ${t.label}`);
      
      audio.play().then(() => {
        playerBox.classList.remove('is-loading');
        announcePlayer(`Playing ${t.label}`);
      }).catch(err => {
        playerBox.classList.remove('is-loading');
        console.error("Audio playback error:", err);
        announcePlayer(`Failed to play ${t.label}`);
      });
    });
    tracksBar.appendChild(b);
  });

  // play/pause
  playBtn.addEventListener('click', () => {
    if (audio.paused) {
      playerBox.classList.add('is-loading');
      audio.play().then(() => {
        playerBox.classList.remove('is-loading');
        if (activeBtn) {
          announcePlayer(`Playing ${activeBtn.textContent}`);
        } else {
          announcePlayer("Playing audio");
        }
      }).catch(err => {
        playerBox.classList.remove('is-loading');
        console.error("Audio playback error:", err);
        announcePlayer("Failed to play audio");
      });
    } else {
      audio.pause();
      announcePlayer("Paused");
    }
  });
  
  audio.addEventListener('play', () => setIcon(playBtn, 'pause'));
  audio.addEventListener('pause', () => setIcon(playBtn, 'play'));
  
  // Show loading state
  audio.addEventListener('waiting', () => {
    playerBox.classList.add('is-loading');
  });
  
  audio.addEventListener('canplay', () => {
    playerBox.classList.remove('is-loading');
  });

  // mute
  muteBtn.addEventListener('click', () => {
    audio.muted = !audio.muted;
    setIcon(muteBtn, audio.muted ? 'mute' : 'speaker');
    announcePlayer(audio.muted ? "Muted" : "Unmuted");
  });

  // duration + progress
  audio.addEventListener('loadedmetadata', () => {
    durT.textContent = pretty(audio.duration);
  });
  
  audio.addEventListener('timeupdate', () => {
    if (!audio.duration) return;
    curT.textContent = pretty(audio.currentTime);
    seek.value = (audio.currentTime / audio.duration) * 100;
  });
  
  seek.addEventListener('input', () => {
    if (!audio.duration) return;
    audio.currentTime = (seek.value / 100) * audio.duration;
    curT.textContent = pretty(audio.currentTime);
  });

  // End of track handling
  audio.addEventListener('ended', () => {
    if (activeBtn) {
      const nextTrack = activeBtn.nextElementSibling || tracksBar.firstElementChild;
      if (nextTrack && nextTrack.classList.contains('trk')) {
        nextTrack.click();
      }
    }
    announcePlayer("Track ended");
  });

  // Error handling
  audio.addEventListener('error', () => {
    playerBox.classList.remove('is-loading');
    console.error("Audio error:", audio.error);
    announcePlayer("Audio error occurred");
  });

  /* ================== GALLERY (buttons + swipe) ================== */
  const shot = document.getElementById('shot');
  const stage = document.getElementById('stage');
  const prev = document.getElementById('prev');
  const next = document.getElementById('next');
  const galleryStatus = document.getElementById('galleryStatus');

  // Simplified path and formatting
  const pad2 = n => (n < 10 ? '0' + n : '' + n);
  const BASE = '/mybg/png';  // Direct path to PNG folder
  const IMAGE_COUNT = 65;    // Matches manifest.json

  // Image descriptions for better alt text
  const imageDescriptions = {
    1: "Abstract purple waves with light streams",
    2: "Cyan and magenta digital patterns",
    3: "Glowing pink and blue nebula texture",
    4: "Deep blue fractal design",
    5: "Vibrant red and orange energy waves",
    6: "Geometric neon grid pattern",
    7: "Dark abstract shapes with glowing edges",
    8: "Digital landscape with holographic elements",
    9: "Flowing particle streams in blue and purple",
    10: "Crystalline structures with reflective surfaces",
    11: "Psychedelic wave patterns",
    12: "Cyan and pink audio visualizer patterns",
    13: "Abstract digital terrain in twilight colors",
    14: "Futuristic data visualization grid",
    15: "Neon light trails through darkness",
  };
  
  function getImageDescription(index) {
    return imageDescriptions[index] || `Digital artwork ${index}`;
  }

  // Simplified image loading - no candidates or probing needed
  let images = [];
  let imageIndexes = [];

  (async () => {
    console.log('Starting gallery initialization...');
    const MAX = Math.min(IMAGE_COUNT, 20); // Limit to first 20 images for performance
    const want = 12; // Number of images to use in the gallery
    
    // Build image list directly without probing
    for (let i = 1; i <= MAX && images.length < want; i++) {
      const url = `${BASE}/bg${pad2(i)}.png`;
      images.push(url);
      imageIndexes.push(i);
      console.log(`Added image ${i}: ${url}`);
    }
    
    if (images.length) {
      console.log(`Loaded ${images.length} images`);
      show(0);
      // Preload first few images
      setTimeout(() => {
        prefetch(1, true);
        prefetch(2, false);
      }, 100);
    } else {
      console.error('No images found');
      // Your fallback code here
    }
  })();

  let ix = 0;
  function show(n){
    if (!images.length) return;
    
    ix = (n + images.length) % images.length;
    const url = images[ix];
    const imageIndex = imageIndexes[ix];
    
    console.log(`Showing image ${ix}: ${url}`);
    
    shot.classList.add('loading');
    stage.classList.remove('error');
    
    shot.alt = getImageDescription(imageIndex);
    shot.src = url;
    
    announceGallery(`Image ${ix + 1} of ${images.length}: ${shot.alt}`);
    
    // Prefetch adjacent images
    setTimeout(() => {
      prefetch(ix+1, true);
      prefetch(ix-1, true);
    }, 100);
  }
  
  shot.addEventListener('load', () => {
    console.log('Image loaded successfully');
    shot.classList.remove('loading');
  });
  
  shot.addEventListener('error', () => {
    console.error('Image failed to load:', shot.src);
    shot.classList.remove('loading');
    stage.classList.add('error');
    announceGallery(`Failed to load image ${ix + 1}`);
  });
  
  function prefetch(n, highPriority = false){
    const j = (n + images.length) % images.length;
    const u = images[j];
    
    if (!u || cache.has(u)) return;
    
    const delay = highPriority ? 50 : 300;
    setTimeout(() => {
      if (!cache.has(u)) {
        console.log('Prefetching:', u);
        const im = new Image();
        im.src = u;
        cache.set(u, true);
      }
    }, delay);
  }

  prev.addEventListener('click', () => {
    show(ix-1);
    prev.focus();
  });
  
  next.addEventListener('click', () => {
    show(ix+1);
    next.focus();
  });

  // Keyboard navigation
  stage.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      show(ix-1);
      prev.focus();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      show(ix+1);
      next.focus();
    }
  });

  // swipe left/right without breaking the buttons
  let startX=null, pid=null;
  
  stage.addEventListener('pointerdown', e => {
    if (e.target.closest('.nav')) return;
    startX = e.clientX;
    pid = e.pointerId;
    stage.setPointerCapture(pid);
  });
  
  stage.addEventListener('pointerup', e => {
    if (pid !== e.pointerId) return;
    const dx = e.clientX - startX;
    startX = null;
    pid = null;
    stage.releasePointerCapture(e.pointerId);
    
    if (Math.abs(dx) > 28) {
      show(ix + (dx<0 ? 1 : -1));
    }
  });
  
  stage.addEventListener('pointercancel', e => {
    if (pid !== e.pointerId) return;
    startX = null;
    pid = null;
    stage.releasePointerCapture(e.pointerId);
  });
})();
</script>