<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0a0a0a" />
  <title>The Website</title>

  <!-- JetBrains Mono (UI font) -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --vh: 1vh;
      --font-ui:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;

      --bg:#0a0a0a; --fg:#e8e8e8;

      --fade-dur:15s;        /* bg cross-fade */
      --period:20s;          /* bg dwell time */
      --ui-bottom-pad:72px;
      --bg-current:none;

      --sweep-dur:7.2s;      /* VHS sweep duration per pass */
    }

    *{ -webkit-tap-highlight-color: transparent; box-sizing:border-box }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:var(--font-ui); overflow:hidden;
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    }
    /* Background stack */
    .bg-container{position:fixed; inset:0; z-index:-2}
    .bg-image{
      position:absolute; inset:0;
      background-size:cover; background-position:center;
      opacity:0;
      filter:blur(1.6px) brightness(1.08) saturate(1.08);
      transition:opacity var(--fade-dur) cubic-bezier(.77,0,.18,1);
      will-change:opacity, filter;
    }
    .bg-image.active{opacity:1; z-index:1}

    /* Header / hero (title + nav) */
    header{
      min-height:calc(var(--vh) * 100);
      display:flex; flex-direction:column;
      justify-content:flex-end; align-items:center; text-align:center;
      z-index:10; pointer-events:none;
      padding-bottom:calc(env(safe-area-inset-bottom, 0px) + var(--ui-bottom-pad));
      text-shadow:0 0 1px rgba(0,0,0,.9), 0 0 8px rgba(0,0,0,.6);
      gap: clamp(1.25rem, 5vh, 2.75rem);
    }
    @supports (height: 100svh){ header{ min-height:100svh } }
    @supports (height: 100dvh){ header{ min-height:100dvh } }

    /* TITLE size (restored, tasteful) */
    #glitch-title{ pointer-events:none }
    #glitch-title .tg-letter{
      font-size: clamp(2.6rem, 6.8vw, 5.6rem);  /* balanced hero scale */
      font-weight:800; text-transform:uppercase;
      letter-spacing:.02em; line-height:1.05;
      display:inline-block;
    }

    /* NAV size (restored, tasteful) */
    nav{margin-top:.15em; margin-bottom:clamp(12px, 5vh, 40px)}
    #nav-list{
      list-style:none; padding:0; margin:0;
      display:flex; gap:clamp(1.2rem, 4.8vw, 2.6rem);
      flex-wrap:wrap; justify-content:center;
      pointer-events:auto;
    }
    #nav-list a{
      color:#e9ecef; text-decoration:none;
      font-size: clamp(1.05rem, 2.6vw, 1.6rem);
      letter-spacing:.02em;
      padding: .15em .32em;
      position:relative;
      transition: color .2s ease, text-shadow .2s ease;
    }

    /* Footer (copyright, locked) */
    footer{
      position:fixed; left:0; right:0;
      bottom:env(safe-area-inset-bottom, 0px);
      padding:.5em .7em; z-index:11; pointer-events:none;
      display:block; text-align:left;
    }
    footer p{
      margin:0 .7em;
      display:inline-block;
      background:
        linear-gradient(rgba(0,0,0,.72), rgba(0,0,0,.72)),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.05) 0 1px, transparent 2px 4px);
      padding:.28em .6em; border-radius:6px; letter-spacing:.03em;
      border:1px solid rgba(255,255,255,.1);
      pointer-events:auto; font-size:.83em;
      max-width:88vw; white-space:normal; line-height:1.25; text-align:left;
    }
    @media (pointer: coarse), (max-width: 900px){
      footer{ text-align:center }
      footer p{ margin:0 auto }
    }

    /* Motion button (locked behavior) */
    #ui-top{position:fixed; right:14px; top:calc(env(safe-area-inset-top, 0px) + 14px); z-index:12; display:flex; align-items:center}
    #motionBtn{
      background:
        linear-gradient(rgba(0,0,0,.90), rgba(0,0,0,.90)),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.05) 0 1px, transparent 2px 4px);
      color:var(--fg); border:1px solid rgba(255,255,255,.22);
      border-radius:6px; padding:8px 10px; cursor:pointer; font-family:var(--font-ui)
    }

    /* CRT overlays
       Order: vignette (under), scanlines, RGB drift, sweep (topmost of overlays)
       Minis sit above overlays. Title/nav are below overlays. */
    .crt-vignette{
      position:fixed; inset:0; z-index:38; pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 80%, rgba(0,0,0,.26), rgba(0,0,0,0) 48%),
        radial-gradient(120% 120% at 50% -20%, rgba(0,0,0,.26), rgba(0,0,0,0) 48%);
      mix-blend-mode:multiply;
    }
    .scanlines{
      position:fixed; inset:0; z-index:40; pointer-events:none; mix-blend-mode:multiply;
      background-image:repeating-linear-gradient(
        rgba(0,0,0,0.42) 0px,
        rgba(0,0,0,0.42) 1.2px,
        rgba(0,0,0,0.18) 2.2px,
        rgba(0,0,0,0.30) 3.2px,
        rgba(0,0,0,0.16) 4.4px,
        rgba(0,0,0,0.30) 6px
      );
      animation:scanlineGlitch 2.6s steps(2) infinite;
      mask-image:linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
      -webkit-mask-image:linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
    }
    @keyframes scanlineGlitch{
      0%,100%{transform:translateY(0)}
      35%{transform:translateY(-1px)}
      65%{transform:translateY(1px)}
    }
    .scanlines-rgb{
      position:fixed; inset:0; z-index:41; pointer-events:none; mix-blend-mode:screen; opacity:.085;
      background-image:
        repeating-linear-gradient(to bottom, rgba(255,0,76,.085) 0 2px, transparent 4px),
        repeating-linear-gradient(to bottom, rgba(0,255,200,.085) 0 2px, transparent 4px),
        repeating-linear-gradient(to bottom, rgba(0,170,255,.085) 0 2px, transparent 4px);
      animation:rgbDrift 10s ease-in-out infinite alternate;
    }
    @keyframes rgbDrift{ 0%{ transform:translateX(0) } 100%{ transform:translateX(1.2px) } }
    .scanlines-rgb.glitch{ opacity:.13; transform:translateX(1.7px); transition:opacity .2s ease, transform .2s ease }

    .scanline-sweep{
      position:fixed; left:0; right:0; top:-26vh; height:26vh;
      z-index:45; pointer-events:none;
      /* distorted + translucent, affects title/nav underneath */
      filter:url(#crt-sweep-noise-strong);
      backdrop-filter:contrast(1.55) brightness(1.06) saturate(1.18) hue-rotate(2deg) blur(1.1px);
      -webkit-backdrop-filter:contrast(1.55) brightness(1.06) saturate(1.18) hue-rotate(2deg) blur(1.1px);
      -webkit-mask-image:linear-gradient(to bottom, transparent 0%, #fff 18%, #fff 82%, transparent 100%);
      mask-image:linear-gradient(to bottom, transparent 0%, #fff 18%, #fff 82%, transparent 100%);
      mix-blend-mode:screen; opacity:.22; will-change:transform, filter;
    }
    :root.no-bdf .scanline-sweep{
      backdrop-filter:none; -webkit-backdrop-filter:none;
      filter:url(#crt-sweep-noise-strong);
      opacity:.18;
    }

    /* Mini popup container (always above overlays) */
    .mini{
      position:fixed; z-index:100; width:min(92vw,680px); max-height:min(80vh,640px);
      overflow:auto; padding:16px 18px; color:var(--fg);
      background:rgba(0,0,0,.86); border:1px solid rgba(255,255,255,.12); border-radius:6px;
      box-shadow:0 6px 40px rgba(0,0,0,.55)
    }
    .mini .close{ position:absolute; top:8px; right:8px; background:transparent; border:0; color:var(--fg); font-size:1.2rem; cursor:pointer }

    @media (pointer: coarse), (max-width: 900px){
      #nav-list a{ font-size: clamp(1rem, 4.4vw, 1.45rem) }
    }

    @media (prefers-reduced-motion: reduce){
      .scanlines, .scanlines-rgb, .scanline-sweep, .crt-vignette{display:none !important}
      .bg-image{transition-duration:.3s; filter:none}
    }

    a,button,[tabindex]{outline:none}
    a:focus-visible,button:focus-visible,[tabindex]:focus-visible{
      box-shadow:0 0 0 2px #00ffc8, 0 0 12px 2px rgba(0,255,200,.35);
      border-radius:4px
    }

    /* Sweep animation keyframes */
    @keyframes sweepDown{
      0%   { transform: translateY(-100vh) }
      100% { transform: translateY(200vh)  }
    }
    .scanline-sweep.run{ animation: sweepDown var(--sweep-dur) cubic-bezier(.22,.61,.36,1) forwards }
  </style>
</head>
<body>
  <!-- inline filter for CRT sweep -->
  <svg aria-hidden="true" focusable="false" width="0" height="0" style="position:fixed;inset:auto;pointer-events:none">
    <filter id="crt-sweep-noise-strong">
      <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="9" result="n"/>
      <feColorMatrix type="saturate" values="0" />
      <feDisplacementMap in="SourceGraphic" in2="n" scale="14" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
  </svg>

  <div class="bg-container" id="bg-container"></div>

  <header>
    <h1 class="sr-only">Travis Inskeep</h1>
    <div id="glitch-title" data-text="TRAVIS INSKEEP" aria-hidden="true"></div>
    <nav>
      <ul id="nav-list">
        <li><a href="#about">About</a></li>
        <li><a href="#portfolio">Portfolio</a></li>
        <li><a href="#contact">Contact</a></li>
      </ul>
    </nav>
  </header>

  <!-- Copyright (locked placement) -->
  <footer><p>© 2025 renegadeRenderco<br>All rights reserved</p></footer>

  <!-- Motion toggle (locked behavior) -->
  <div id="ui-top"><button id="motionBtn" type="button" aria-pressed="true">Motion: On</button></div>

  <!-- CRT overlays: title/nav sit under these; minis sit above -->
  <div class="crt-vignette"></div>
  <div class="scanlines"></div>
  <div class="scanlines-rgb" id="scanRGB"></div>
  <div class="scanline-sweep" id="scanSweep"></div>

  <script>
    "use strict";

    /* Capability fallback for expensive filters */
    (function setBackdropSupport(){
      const weak = (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2);
      const supportsBdf = CSS && (CSS.supports('backdrop-filter: blur(1px)') || CSS.supports('-webkit-backdrop-filter: blur(1px)'));
      if(!supportsBdf || weak){ document.documentElement.classList.add('no-bdf'); }
    })();

    /* Viewport + footer pad */
    function setVH(){ const vh = window.innerHeight * 0.01; document.documentElement.style.setProperty('--vh', vh + 'px'); }
    function measureBottomUI(){
      const f = document.querySelector('footer'); const fh = f ? f.getBoundingClientRect().height : 0;
      const pad = Math.ceil(fh + 18);
      document.documentElement.style.setProperty('--ui-bottom-pad', pad + 'px');
    }
    setVH(); measureBottomUI();
    window.addEventListener('resize', ()=>{ setVH(); measureBottomUI(); }, {passive:true});
    window.addEventListener('orientationchange', ()=>{ setVH(); setTimeout(measureBottomUI, 120); });
    window.addEventListener('load', ()=>{ measureBottomUI(); setTimeout(measureBottomUI, 500); });

    /* Background slideshow - simplified */
    const $ = s => document.querySelector(s);
    const bgContainer = $("#bg-container");
    
    if (bgContainer) {
      const PERIOD_MS = 20000;
      const IMAGE_COUNT = 65;
      
      function pad2(n) { return n < 10 ? "0" + n : "" + n; }
      function shuffle(arr) { 
        for(let i = arr.length - 1; i > 0; i--) { 
          const j = Math.floor(Math.random() * (i + 1)); 
          [arr[i], arr[j]] = [arr[j], arr[i]]; 
        } 
        return arr; 
      }
      
      // Create two layers for crossfading
      const layers = [document.createElement("div"), document.createElement("div")];
      layers.forEach(l => { 
        l.className = "bg-image"; 
        bgContainer.appendChild(l); 
      });
      
      let active = 0;
      let imageIndex = 1;
      let shuffledOrder = shuffle(Array.from({length: IMAGE_COUNT}, (_, i) => i + 1));
      let orderPosition = 0;
      
      function getNextImageUrl() {
        if (orderPosition >= shuffledOrder.length) {
          shuffledOrder = shuffle(Array.from({length: IMAGE_COUNT}, (_, i) => i + 1));
          orderPosition = 0;
        }
        const num = shuffledOrder[orderPosition++];
        return `mybg/webp/bg${pad2(num)}.webp`;
      }
      
      function showNextImage() {
        const url = getNextImageUrl();
        const currentLayer = layers[active];
        const nextLayer = layers[active ^ 1];
        
        // Preload the image
        const img = new Image();
        img.onload = () => {
          // Set the background and show the layer
          nextLayer.style.backgroundImage = `url("${url}")`;
          nextLayer.classList.add("active");
          
          // Hide the previous layer after transition
          setTimeout(() => {
            currentLayer.classList.remove("active");
          }, 100);
          
          // Switch active layer
          active ^= 1;
          
          document.documentElement.style.setProperty("--bg-current", `url("${url}")`);
        };
        img.onerror = () => {
          console.warn('Failed to load background image:', url);
          // Try next image
          setTimeout(showNextImage, 1000);
        };
        img.src = url;
      }
      
      // Show first image immediately
      showNextImage();
      
      // Motion toggle (no visual side-effects besides pausing)
      const Motion = { paused: false };
      function setMotion(on) {
        Motion.paused = !on;
        document.documentElement.dataset.motion = on ? "on" : "paused";
        const b = $("#motionBtn");
        if (b) {
          b.textContent = on ? "Motion: On" : "Motion: Off";
          b.setAttribute("aria-pressed", on ? "true" : "false");
        }
      }
      setMotion(true);
      
      const motionBtn = $("#motionBtn");
      if (motionBtn) {
        motionBtn.addEventListener("click", () => {
          setMotion(motionBtn.getAttribute("aria-pressed") !== "true");
        }, {passive: true});
      }
      
      // Start the slideshow interval
      setInterval(() => {
        if (!Motion.paused) {
          showNextImage();
        }
      }, PERIOD_MS);
      
      // Pause when tab hidden
      let wasPaused = false;
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          wasPaused = Motion.paused;
          setMotion(false);
        } else {
          setMotion(!wasPaused);
        }
      });
    }

    /* VHS sweep control (translucent, distorted) */
    const sweepEl = document.getElementById("scanSweep"); 
    const rgbEl = document.getElementById("scanRGB");
    
    if (sweepEl && rgbEl) {
      function runSweep(){
        const dur = (Math.random()*2.2 + 5.8).toFixed(2) + "s";
        sweepEl.style.setProperty('--sweep-dur', dur);
        sweepEl.style.opacity = (Math.random()*0.08 + 0.18).toFixed(2);
        sweepEl.classList.remove('run'); 
        void sweepEl.offsetWidth; 
        sweepEl.classList.add('run');
        
        function tick(){
          if(document.documentElement.dataset.motion === "paused" || !sweepEl.classList.contains('run')) return;
          sweepEl.style.transform = `translateX(${(Math.random()>0.5?1:-1)*(Math.random()*1.8)}px)`;
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }
      
      sweepEl.addEventListener('animationend', e=>{
        if(e.animationName === 'sweepDown'){ 
          sweepEl.classList.remove('run'); 
          sweepEl.style.transform='translateX(0)'; 
        }
      });
      
      (function sweepLoop(){ 
        const t = 9000 + Math.random()*16000; 
        setTimeout(()=>{ 
          if(document.documentElement.dataset.motion!=="paused") runSweep(); 
          sweepLoop(); 
        }, t); 
      })();
      
      (function rgbGlitchLoop(){ 
        const t = 5000 + Math.random()*9000; 
        setTimeout(()=>{ 
          if(document.documentElement.dataset.motion!=="paused"){ 
            rgbEl.classList.add('glitch'); 
            setTimeout(()=> rgbEl.classList.remove('glitch'), Math.random()*140+160); 
          } 
          rgbGlitchLoop(); 
        }, t); 
      })();
    }

    /* Mini windows: fetch fragments and align along same baseline above nav */
    function placeMini(mini){
      const nav = document.getElementById('nav-list');
      const nr = nav.getBoundingClientRect();
      const mr = mini.getBoundingClientRect();
      const left = window.innerWidth/2;
      const top  = nr.top - mr.height - 16;
      mini.style.left = `${left}px`;
      mini.style.top  = `${Math.max(16, top)}px`;
      mini.style.transform = "translate(-50%, 0)";
    }

    function openMiniFromLink(linkEl, html){
      const mini=document.createElement("div");
      mini.className="mini";
      mini.dataset.src = linkEl.getAttribute("href").slice(1);
      mini.innerHTML=`<button class="close" aria-label="Close">✕</button>${html}`;
      document.body.appendChild(mini);
      placeMini(mini);

      const close=()=>{ mini.remove(); linkEl.focus(); };
      mini.querySelector(".close").addEventListener("click", close);
      const outside=e=>{ if(!mini.contains(e.target)) { close(); document.removeEventListener("mousedown", outside);} };
      setTimeout(()=> document.addEventListener("mousedown", outside), 0);
      const onEsc = e=>{ if(e.key==="Escape"){ close(); document.removeEventListener("keydown", onEsc);} };
      document.addEventListener("keydown", onEsc);

      // reposition on viewport changes
      const onResize = ()=> placeMini(mini);
      window.addEventListener("resize", onResize, {passive:true});
      window.addEventListener("orientationchange", onResize, {passive:true});
    }

    async function fetchMini(path){
      const resp = await fetch(path, {cache:"no-store"});
      if(!resp.ok) throw new Error("mini fetch failed");
      return resp.text();
    }

    document.querySelectorAll('#nav-list a[href^="#"]').forEach(a=>{
      a.addEventListener("click", async e=>{
        e.preventDefault();
        const id=a.getAttribute("href").slice(1);
        const existing = document.querySelector('.mini');
        if(existing){ const was=existing.dataset.src; existing.remove(); if(was===id) return; }
        let frag="";
        if(id==="about") frag = await fetchMini("assets/minis/about.html");
        else if(id==="portfolio") frag = await fetchMini("assets/minis/portfolio.html");
        else if(id==="contact") frag = await fetchMini("assets/minis/contact.html");
        openMiniFromLink(a, frag);
      }, {passive:false});
    });
  </script>

  <!-- Title and nav glitch engines -->
  <script defer src="assets/js/title-glitch.js"></script>
  <script defer src="assets/js/nav-glitch.js"></script>
</body>
</html>