<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Browser Comparison Test</title>
    <style>
      body {
        margin: 0;
        font-family: "Courier New", monospace;
        background: #000;
        color: #0f0;
        padding: 10px;
        font-size: 12px;
      }
      .test-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        height: 100vh;
      }
      .test-section {
        border: 1px solid #333;
        padding: 10px;
        overflow: auto;
      }
      .test-preview {
        width: 100%;
        height: 300px;
        border: 2px solid #555;
        position: relative;
        overflow: hidden;
      }
      .bg-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .bg-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        opacity: 0;
        transition: opacity var(--fade-dur, 2s) ease-in-out;
      }
      .bg-image.active {
        opacity: 1;
      }
      :root {
        --fade-dur: 2s;
        --period: 7s;
      }
      .status-line {
        padding: 3px 0;
        border-bottom: 1px solid #222;
      }
      .success {
        color: #0f0;
      }
      .error {
        color: #f00;
      }
      .warning {
        color: #fa0;
      }
      .log {
        background: #111;
        padding: 10px;
        margin: 10px 0;
        height: 200px;
        overflow-y: scroll;
        font-size: 10px;
      }
      button {
        background: #333;
        color: #0f0;
        border: 1px solid #555;
        padding: 5px 10px;
        margin: 2px;
        cursor: pointer;
      }
      button:hover {
        background: #444;
      }
      .timer-display {
        font-size: 18px;
        text-align: center;
        padding: 10px;
        background: #222;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <h2>üîç BROWSER COMPATIBILITY TEST</h2>

    <div class="test-grid">
      <!-- LEFT: Current Method Test -->
      <div class="test-section">
        <h3>üìä CURRENT BG-LOADER METHOD</h3>

        <div class="status-line">
          <strong>Browser:</strong>
          <span id="browser-current">Detecting...</span>
        </div>
        <div class="status-line">
          <strong>CSS Support:</strong> <span id="css-support">Testing...</span>
        </div>
        <div class="status-line">
          <strong>Fetch API:</strong> <span id="fetch-support">Testing...</span>
        </div>
        <div class="status-line">
          <strong>Rotation Status:</strong>
          <span id="rotation-status">Stopped</span>
        </div>

        <div class="timer-display" id="current-timer">0s</div>

        <div class="test-preview" id="current-preview">
          <div class="bg-container" id="current-bg-container"></div>
        </div>

        <button onclick="testCurrentMethod()">Start Current Method</button>
        <button onclick="stopCurrentMethod()">Stop</button>

        <div class="log" id="current-log"></div>
      </div>

      <!-- RIGHT: Fallback Method Test -->
      <div class="test-section">
        <h3>üõ†Ô∏è FALLBACK COMPATIBLE METHOD</h3>

        <div class="status-line">
          <strong>Method:</strong>
          <span id="fallback-method">JavaScript Timer</span>
        </div>
        <div class="status-line">
          <strong>Image Loading:</strong>
          <span id="fallback-loading">Ready</span>
        </div>
        <div class="status-line">
          <strong>Compatibility:</strong>
          <span id="fallback-compat">Universal</span>
        </div>
        <div class="status-line">
          <strong>Rotation Status:</strong>
          <span id="fallback-status">Stopped</span>
        </div>

        <div class="timer-display" id="fallback-timer">0s</div>

        <div class="test-preview" id="fallback-preview">
          <div class="bg-container" id="fallback-bg-container"></div>
        </div>

        <button onclick="testFallbackMethod()">Start Fallback Method</button>
        <button onclick="stopFallbackMethod()">Stop</button>

        <div class="log" id="fallback-log"></div>
      </div>
    </div>

    <script>
      // Browser Detection
      function detectBrowser() {
        const ua = navigator.userAgent;
        let browser = "Unknown";
        if (ua.includes("Chrome") && !ua.includes("Edg"))
          browser = "Chrome/Chromium";
        else if (ua.includes("Firefox")) browser = "Firefox";
        else if (ua.includes("Safari") && !ua.includes("Chrome"))
          browser = "Safari";
        else if (ua.includes("Edg")) browser = "Edge";
        else if (ua.includes("VSCode")) browser = "VS Code Simple Browser";

        document.getElementById("browser-current").textContent = browser;
        return browser;
      }

      // Test CSS Custom Properties
      function testCSSSupport() {
        try {
          const testEl = document.createElement("div");
          testEl.style.setProperty("--test", "7s");
          const value = getComputedStyle(testEl).getPropertyValue("--test");
          const supported = value.trim() === "7s";

          document.getElementById("css-support").textContent = supported
            ? "Supported ‚úÖ"
            : "Not Supported ‚ùå";
          document.getElementById("css-support").className = supported
            ? "success"
            : "error";
          return supported;
        } catch (e) {
          document.getElementById("css-support").textContent = "Error ‚ùå";
          document.getElementById("css-support").className = "error";
          return false;
        }
      }

      // Test Fetch API
      function testFetchAPI() {
        const supported = typeof fetch !== "undefined";
        document.getElementById("fetch-support").textContent = supported
          ? "Available ‚úÖ"
          : "Not Available ‚ùå";
        document.getElementById("fetch-support").className = supported
          ? "success"
          : "error";
        return supported;
      }

      // Logging utilities
      function logCurrent(message) {
        const log = document.getElementById("current-log");
        const timestamp = new Date().toLocaleTimeString();
        log.innerHTML += `[${timestamp}] ${message}\n`;
        log.scrollTop = log.scrollHeight;
      }

      function logFallback(message) {
        const log = document.getElementById("fallback-log");
        const timestamp = new Date().toLocaleTimeString();
        log.innerHTML += `[${timestamp}] ${message}\n`;
        log.scrollTop = log.scrollHeight;
      }

      // Current Method Variables
      let currentInterval = null;
      let currentImages = [];
      let currentIndex = 0;
      let currentStartTime = null;

      // Fallback Method Variables
      let fallbackInterval = null;
      let fallbackImages = [];
      let fallbackIndex = 0;
      let fallbackStartTime = null;

      // Test Current bg-loader Method
      async function testCurrentMethod() {
        logCurrent("üöÄ Starting current method test...");
        currentStartTime = Date.now();

        try {
          // Test manifest loading (current method)
          const response = await fetch("manifest.json");
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const manifest = await response.json();

          logCurrent(`‚úÖ Manifest loaded: ${manifest.count} images`);

          // Generate image paths
          currentImages = [];
          for (let i = 1; i <= manifest.count; i++) {
            const num =
              manifest.pad && manifest.count > 9
                ? String(i).padStart(2, "0")
                : i;
            const path = `${manifest.path}/bg${num}.${manifest.extension}`;
            currentImages.push(path);
          }

          // Get CSS period
          const period = getComputedStyle(
            document.documentElement
          ).getPropertyValue("--period");
          const periodMs = parseFloat(period) * 1000 || 7000;

          logCurrent(`üéõÔ∏è CSS Period: ${period} (${periodMs}ms)`);

          // Start rotation
          currentRotation();
          currentInterval = setInterval(currentRotation, periodMs);

          document.getElementById("rotation-status").textContent = "Running ‚úÖ";
          document.getElementById("rotation-status").className = "success";
        } catch (error) {
          logCurrent(`‚ùå Current method failed: ${error.message}`);
          document.getElementById("rotation-status").textContent = "Failed ‚ùå";
          document.getElementById("rotation-status").className = "error";
        }
      }

      function currentRotation() {
        if (!currentImages.length) return;

        const container = document.getElementById("current-bg-container");
        const newImage = currentImages[currentIndex];

        // Clear previous images
        container.innerHTML = "";

        // Create new background element
        const bgEl = document.createElement("div");
        bgEl.className = "bg-image";
        bgEl.style.backgroundImage = `url(${newImage})`;
        container.appendChild(bgEl);

        // Trigger fade-in
        setTimeout(() => bgEl.classList.add("active"), 100);

        logCurrent(`üñºÔ∏è Rotated to: bg${currentIndex + 1}.png`);
        currentIndex = (currentIndex + 1) % currentImages.length;

        // Update timer
        updateCurrentTimer();
      }

      function updateCurrentTimer() {
        if (!currentStartTime) return;
        const elapsed = Math.floor((Date.now() - currentStartTime) / 1000);
        document.getElementById("current-timer").textContent = `${elapsed}s`;
      }

      function stopCurrentMethod() {
        if (currentInterval) {
          clearInterval(currentInterval);
          currentInterval = null;
        }
        document.getElementById("rotation-status").textContent = "Stopped ‚èπÔ∏è";
        document.getElementById("rotation-status").className = "warning";
        logCurrent("‚èπÔ∏è Current method stopped");
      }

      // Test Fallback Method (JavaScript-based)
      async function testFallbackMethod() {
        logFallback("üöÄ Starting fallback method test...");
        fallbackStartTime = Date.now();

        try {
          // Use XMLHttpRequest as fallback to fetch
          const manifest = await loadManifestFallback();
          logFallback(
            `‚úÖ Manifest loaded (XMLHttpRequest): ${manifest.count} images`
          );

          // Generate image paths
          fallbackImages = [];
          for (let i = 1; i <= manifest.count; i++) {
            const num =
              manifest.pad && manifest.count > 9
                ? String(i).padStart(2, "0")
                : i;
            const path = `${manifest.path}/bg${num}.${manifest.extension}`;
            fallbackImages.push(path);
          }

          // Use fixed JavaScript timing instead of CSS
          const periodMs = 7000; // Hard-coded 7 seconds
          logFallback(`üéõÔ∏è Fixed Period: ${periodMs}ms`);

          // Start rotation
          fallbackRotation();
          fallbackInterval = setInterval(fallbackRotation, periodMs);

          document.getElementById("fallback-status").textContent = "Running ‚úÖ";
          document.getElementById("fallback-status").className = "success";
        } catch (error) {
          logFallback(`‚ùå Fallback method failed: ${error.message}`);
          document.getElementById("fallback-status").textContent = "Failed ‚ùå";
          document.getElementById("fallback-status").className = "error";
        }
      }

      function loadManifestFallback() {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("GET", "manifest.json", true);
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                try {
                  resolve(JSON.parse(xhr.responseText));
                } catch (e) {
                  reject(new Error("JSON parse error"));
                }
              } else {
                reject(new Error(`HTTP ${xhr.status}`));
              }
            }
          };
          xhr.onerror = () => reject(new Error("Network error"));
          xhr.send();
        });
      }

      function fallbackRotation() {
        if (!fallbackImages.length) return;

        const container = document.getElementById("fallback-bg-container");
        const newImage = fallbackImages[fallbackIndex];

        // Clear previous images
        container.innerHTML = "";

        // Create new background element with inline transition
        const bgEl = document.createElement("div");
        bgEl.className = "bg-image";
        bgEl.style.backgroundImage = `url(${newImage})`;
        bgEl.style.transition = "opacity 2s ease-in-out"; // Inline fallback
        container.appendChild(bgEl);

        // Trigger fade-in
        setTimeout(() => (bgEl.style.opacity = "1"), 100);

        logFallback(`üñºÔ∏è Rotated to: bg${fallbackIndex + 1}.png`);
        fallbackIndex = (fallbackIndex + 1) % fallbackImages.length;

        // Update timer
        updateFallbackTimer();
      }

      function updateFallbackTimer() {
        if (!fallbackStartTime) return;
        const elapsed = Math.floor((Date.now() - fallbackStartTime) / 1000);
        document.getElementById("fallback-timer").textContent = `${elapsed}s`;
      }

      function stopFallbackMethod() {
        if (fallbackInterval) {
          clearInterval(fallbackInterval);
          fallbackInterval = null;
        }
        document.getElementById("fallback-status").textContent = "Stopped ‚èπÔ∏è";
        document.getElementById("fallback-status").className = "warning";
        logFallback("‚èπÔ∏è Fallback method stopped");
      }

      // Timer updates
      setInterval(() => {
        updateCurrentTimer();
        updateFallbackTimer();
      }, 1000);

      // Initialize
      window.addEventListener("load", () => {
        detectBrowser();
        testCSSSupport();
        testFetchAPI();

        logCurrent("üîÑ Ready to test current bg-loader method");
        logFallback("üîÑ Ready to test fallback compatibility method");
      });
    </script>
  </body>
</html>
