<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CRT Effects - Modular System Test</title>
    <link rel="stylesheet" href="../assets/css/crt.css" />
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #000;
        color: #00ff00;
        font-family: "Courier New", monospace;
        min-height: 100vh;
      }

      .test-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        border: 1px solid #00ff00;
        background: rgba(0, 255, 0, 0.05);
      }

      .test-section {
        margin-bottom: 30px;
        padding: 15px;
        border: 1px solid rgba(0, 255, 0, 0.3);
      }

      .test-section h2 {
        color: #00ff00;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-top: 0;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .control-button {
        background: none;
        border: 1px solid #00ff00;
        color: #00ff00;
        padding: 8px 16px;
        cursor: pointer;
        font-family: inherit;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .control-button:hover {
        background: rgba(0, 255, 0, 0.2);
      }

      .control-button.active {
        background: rgba(0, 255, 0, 0.3);
      }

      .status-display {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ff00;
        padding: 10px;
        margin-top: 10px;
        font-size: 12px;
        white-space: pre-wrap;
      }

      .demo-text {
        font-size: 24px;
        line-height: 1.5;
        text-align: center;
        margin: 20px 0;
        padding: 20px;
        border: 1px dashed #00ff00;
      }

      .performance-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ff00;
        padding: 10px;
        font-size: 12px;
        z-index: 1000;
      }

      .debug-hint {
        position: fixed;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ff00;
        padding: 10px;
        font-size: 12px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div class="performance-info" id="performance-info">
      FPS: <span id="fps-counter">--</span> | Performance:
      <span id="perf-level">--</span>
    </div>

    <div class="test-container">
      <h1>CRT Effects Modular System Test</h1>

      <div class="test-section">
        <h2>System Status</h2>
        <div class="controls">
          <button class="control-button" id="test-system">
            Test All Systems
          </button>
          <button class="control-button" id="run-migration">
            Run Migration
          </button>
          <button class="control-button" id="reset-effects">
            Reset Effects
          </button>
        </div>
        <div class="status-display" id="system-status">Loading...</div>
      </div>

      <div class="test-section">
        <h2>Performance Controls</h2>
        <div class="controls">
          <button class="control-button active" id="perf-auto">
            Auto Mode
          </button>
          <button class="control-button" id="perf-maximum">
            Maximum Quality
          </button>
          <button class="control-button" id="perf-balanced">Balanced</button>
          <button class="control-button" id="perf-performance">
            Performance
          </button>
        </div>
        <div class="status-display" id="performance-status">
          Auto performance mode enabled
        </div>
      </div>

      <div class="test-section">
        <h2>Individual Effects</h2>
        <div class="controls" id="effect-controls">
          <!-- Effect controls will be populated by JavaScript -->
        </div>
        <div class="status-display" id="effects-status">Loading effects...</div>
      </div>

      <div class="demo-text">
        THIS IS A TEST OF THE CRT EFFECTS SYSTEM
        <br />
        RETRO TERMINAL AESTHETIC WITH MODERN PERFORMANCE
        <br />
        MODULAR ARCHITECTURE • INTELLIGENT OPTIMIZATION
      </div>

      <div class="test-section">
        <h2>Visual Test Elements</h2>
        <div
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
          "
        >
          <div
            style="border: 1px solid #00ff00; padding: 15px; text-align: center"
          >
            <h3>Scanlines Test</h3>
            <div
              style="
                height: 100px;
                background: linear-gradient(to right, #00ff00, #0080ff);
              "
            ></div>
          </div>
          <div
            style="border: 1px solid #00ff00; padding: 15px; text-align: center"
          >
            <h3>Distortion Test</h3>
            <div
              style="
                height: 100px;
                background: radial-gradient(circle, #ff0080, #00ff00);
              "
            ></div>
          </div>
          <div
            style="border: 1px solid #00ff00; padding: 15px; text-align: center"
          >
            <h3>Color Test</h3>
            <div
              style="
                height: 100px;
                background: linear-gradient(45deg, #ff0000, #00ff00, #0000ff);
              "
            ></div>
          </div>
        </div>
      </div>
    </div>

    <div class="debug-hint">
      Press <strong>Ctrl/Cmd + Shift + D</strong> for Debug Panel
    </div>

    <!-- Core CRT Effects CSS -->
    <style id="crt-effects-styles">
      /* Base CRT container styles will be injected here */
    </style>

    <!-- Load all modular components in correct order -->

    <!-- Performance and monitoring -->
    <script src="../assets/js/performance-monitor.js"></script>
    <script src="../assets/js/advanced-performance-optimizer.js"></script>

    <!-- Individual effect modules -->
    <script src="../assets/js/effects/scanlines-effect.js"></script>
    <script src="../assets/js/effects/barrel-distortion-effect.js"></script>
    <script src="../assets/js/effects/tracking-error-effect.js"></script>
    <script src="../assets/js/effects/vignette-effect.js"></script>
    <script src="../assets/js/effects/chroma-bleed-effect.js"></script>
    <script src="../assets/js/effects/rgb-separation-effect.js"></script>

    <!-- Registry and management systems -->
    <script src="../assets/js/crt-effect-registry.js"></script>
    <script src="../assets/js/legacy-migration-manager.js"></script>

    <!-- Debug panel -->
    <script src="../assets/js/crt-debug-panel.js"></script>

    <script>
      // Test page controller
      class CRTTestController {
        constructor() {
          this.systems = {};
          this.currentPerfMode = "auto";
          this.init();
        }

        async init() {
          console.log("[Test] Initializing CRT Test Controller...");

          // Wait for all systems to be available
          await this.waitForSystems();

          // Initialize all systems
          this.initializeSystems();

          // Setup UI event listeners
          this.setupEventListeners();

          // Start monitoring
          this.startMonitoring();

          // Update initial status
          this.updateSystemStatus();
          this.updateEffectControls();

          console.log("[Test] CRT Test Controller initialized");
        }

        async waitForSystems() {
          const systemChecks = [
            "PerformanceMonitor",
            "AdvancedPerformanceOptimizer",
            "CRTEffectRegistry",
            "CRTLegacyMigrationManager",
            "CRTDebugPanel",
          ];

          let attempts = 0;
          const maxAttempts = 50;

          while (attempts < maxAttempts) {
            const available = systemChecks.filter((sys) => window[sys]);

            if (available.length === systemChecks.length) {
              console.log("[Test] All systems loaded successfully");
              return;
            }

            console.log(
              `[Test] Waiting for systems... (${available.length}/${systemChecks.length})`
            );
            await new Promise((resolve) => setTimeout(resolve, 100));
            attempts++;
          }

          console.warn("[Test] Some systems may not have loaded");
        }

        initializeSystems() {
          try {
            // Initialize performance monitoring
            if (window.PerformanceMonitor) {
              this.systems.performanceMonitor =
                window.PerformanceMonitor.init();
              console.log("[Test] Performance Monitor initialized");
            }

            // Initialize advanced optimizer
            if (window.AdvancedPerformanceOptimizer) {
              this.systems.optimizer =
                window.AdvancedPerformanceOptimizer.init();
              console.log("[Test] Advanced Performance Optimizer initialized");
            }

            // Register all available effects
            if (window.CRTEffectRegistry) {
              this.registerAllEffects();
              console.log("[Test] Effect Registry initialized");
            }

            // Mark body as CRT container
            document.body.classList.add("crt-container");
          } catch (error) {
            console.error("[Test] Error initializing systems:", error);
          }
        }

        registerAllEffects() {
          const effectClasses = [
            "ScanlinesEffect",
            "BarrelDistortionEffect",
            "TrackingErrorEffect",
            "VignetteEffect",
            "ChromaBleedEffect",
            "RGBSeparationEffect",
          ];

          effectClasses.forEach((className) => {
            if (window[className]) {
              window.CRTEffectRegistry.register(
                className.replace("Effect", "").toLowerCase(),
                window[className]
              );
              console.log(`[Test] Registered ${className}`);
            }
          });

          // Enable all effects initially
          setTimeout(() => {
            window.CRTEffectRegistry.enableAll();
            console.log("[Test] All effects enabled");
          }, 100);
        }

        setupEventListeners() {
          // System controls
          document
            .getElementById("test-system")
            ?.addEventListener("click", () => this.testAllSystems());
          document
            .getElementById("run-migration")
            ?.addEventListener("click", () => this.runMigration());
          document
            .getElementById("reset-effects")
            ?.addEventListener("click", () => this.resetEffects());

          // Performance controls
          ["auto", "maximum", "balanced", "performance"].forEach((mode) => {
            document
              .getElementById(`perf-${mode}`)
              ?.addEventListener("click", () => this.setPerformanceMode(mode));
          });
        }

        startMonitoring() {
          // Update performance display every 500ms
          setInterval(() => {
            this.updatePerformanceDisplay();
          }, 500);
        }

        updatePerformanceDisplay() {
          const fpsElement = document.getElementById("fps-counter");
          const perfElement = document.getElementById("perf-level");

          if (this.systems.performanceMonitor) {
            const metrics = this.systems.performanceMonitor.getMetrics();
            if (fpsElement)
              fpsElement.textContent = metrics.avgFps?.toFixed(1) || "--";
            if (perfElement)
              perfElement.textContent = metrics.performanceLevel || "--";
          }
        }

        updateSystemStatus() {
          const statusElement = document.getElementById("system-status");
          if (!statusElement) return;

          const systems = {
            "Performance Monitor": !!window.PerformanceMonitor,
            "Advanced Optimizer": !!window.AdvancedPerformanceOptimizer,
            "Effect Registry": !!window.CRTEffectRegistry,
            "Migration Manager": !!window.CRTLegacyMigrationManager,
            "Debug Panel": !!window.CRTDebugPanel,
          };

          const systemStatus = Object.entries(systems)
            .map(
              ([name, available]) =>
                `${name}: ${available ? "✓ Available" : "✗ Missing"}`
            )
            .join("\n");

          // Add registry status if available
          if (window.CRTEffectRegistry) {
            const registryStatus = window.CRTEffectRegistry.getStatus();
            statusElement.textContent =
              systemStatus +
              "\n\nRegistered Effects: " +
              Object.keys(registryStatus.registeredEffects).length +
              "\n" +
              "Active Instances: " +
              Object.keys(registryStatus.activeInstances).length;
          } else {
            statusElement.textContent = systemStatus;
          }
        }

        updateEffectControls() {
          const controlsElement = document.getElementById("effect-controls");
          const statusElement = document.getElementById("effects-status");

          if (!controlsElement || !window.CRTEffectRegistry) return;

          const status = window.CRTEffectRegistry.getStatus();

          // Clear existing controls
          controlsElement.innerHTML = "";

          // Add controls for each registered effect
          Object.keys(status.registeredEffects).forEach((effectName) => {
            const button = document.createElement("button");
            button.className = "control-button";
            button.textContent =
              effectName.charAt(0).toUpperCase() + effectName.slice(1);
            button.dataset.effect = effectName;

            const instance = status.activeInstances[effectName];
            if (instance && instance.state?.enabled) {
              button.classList.add("active");
            }

            button.addEventListener("click", () =>
              this.toggleEffect(effectName)
            );
            controlsElement.appendChild(button);
          });

          // Update status
          if (statusElement) {
            const activeCount = Object.values(status.activeInstances).filter(
              (instance) => instance.state?.enabled
            ).length;
            statusElement.textContent = `${activeCount}/${
              Object.keys(status.registeredEffects).length
            } effects active`;
          }
        }

        toggleEffect(effectName) {
          if (!window.CRTEffectRegistry) return;

          const instance = window.CRTEffectRegistry.getInstance(effectName);
          if (instance) {
            const isEnabled = instance.state?.enabled;
            if (isEnabled && typeof instance.disable === "function") {
              instance.disable();
            } else if (!isEnabled && typeof instance.enable === "function") {
              instance.enable();
            }

            // Update UI
            setTimeout(() => this.updateEffectControls(), 100);
          }
        }

        setPerformanceMode(mode) {
          // Update button states
          document.querySelectorAll('[id^="perf-"]').forEach((btn) => {
            btn.classList.remove("active");
          });
          document.getElementById(`perf-${mode}`)?.classList.add("active");

          this.currentPerfMode = mode;

          // Apply performance mode if optimizer is available
          if (window.AdvancedPerformanceOptimizer) {
            const levels = {
              auto: -1, // Auto mode
              maximum: 5,
              balanced: 3,
              performance: 1,
            };

            if (levels[mode] === -1) {
              window.AdvancedPerformanceOptimizer.enableAutoMode();
            } else {
              window.AdvancedPerformanceOptimizer.setPerformanceLevel(
                levels[mode]
              );
            }
          }

          // Update status
          const statusElement = document.getElementById("performance-status");
          if (statusElement) {
            statusElement.textContent = `Performance mode: ${mode}`;
          }
        }

        testAllSystems() {
          console.log("[Test] Testing all systems...");

          const tests = [];

          // Test performance monitor
          if (this.systems.performanceMonitor) {
            tests.push("Performance Monitor: Working");
          } else {
            tests.push("Performance Monitor: Not available");
          }

          // Test optimizer
          if (this.systems.optimizer) {
            const report = this.systems.optimizer.getPerformanceReport();
            tests.push(
              `Optimizer: Working (Level ${report.currentLevel || "Auto"})`
            );
          } else {
            tests.push("Optimizer: Not available");
          }

          // Test effects
          if (window.CRTEffectRegistry) {
            const status = window.CRTEffectRegistry.getStatus();
            tests.push(
              `Effects: ${Object.keys(status.activeInstances).length} active`
            );
          } else {
            tests.push("Effects: Registry not available");
          }

          // Update status
          const statusElement = document.getElementById("system-status");
          if (statusElement) {
            statusElement.textContent = tests.join("\n");
          }

          console.log("[Test] System test complete");
        }

        async runMigration() {
          if (!window.CRTLegacyMigrationManager) {
            console.warn("[Test] Migration manager not available");
            return;
          }

          try {
            const result =
              await window.CRTLegacyMigrationManager.startMigration();
            console.log("[Test] Migration completed:", result);

            // Update status
            this.updateSystemStatus();
          } catch (error) {
            console.error("[Test] Migration failed:", error);
          }
        }

        resetEffects() {
          if (window.CRTEffectRegistry) {
            window.CRTEffectRegistry.disableAll();
            setTimeout(() => {
              window.CRTEffectRegistry.enableAll();
              this.updateEffectControls();
            }, 500);
          }
        }
      }

      // Initialize test controller when page loads
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          window.testController = new CRTTestController();
        });
      } else {
        window.testController = new CRTTestController();
      }
    </script>
  </body>
</html>
